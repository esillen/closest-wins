<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Spectate - Closest Wins</title>
	<link rel="stylesheet" th:href="@{/css/styles.css}">
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>
	<nav>
		<ul>
			<li><a href="/play">Play</a></li>
			<li><a href="/spectate">Spectate</a></li>
			<li><a href="/join">Join</a></li>
			<li><a href="/players">Players</a></li>
			<li><a href="/admin">Admin</a></li>
		</ul>
	</nav>
	
	<main class="align-start">
		<div class="content full-width">
			<h1>Spectate</h1>
			<div class="spectate-container">
				<div class="spectate-main">
					<div class="status-info">
						<div class="player-count">
							<span id="playerCount">0</span> players with guesses
						</div>
						<div class="update-status" id="updateStatus">
							<span class="pulse"></span>
							<span>Live updates active</span>
						</div>
					</div>
					<div id="map" class="tall"></div>
					<div class="legend">
						üí° This map shows all player guesses in real-time. Markers are color-coded by player and show their emoji.
					</div>
				</div>
				<div class="spectate-sidebar">
					<h2>Leaderboard</h2>
					<div id="leaderboard" class="leaderboard">
						<p class="text-muted">Loading players...</p>
					</div>
				</div>
			</div>
		</div>
	</main>
	
	<script>
		// Function to normalize longitude to -180 to 180 range
		function normalizeLongitude(lng) {
			return ((lng + 180) % 360 + 360) % 360 - 180;
		}
		
		// Initialize map
		const map = L.map('map', {
			worldCopyJump: true,
			maxBounds: [ [-90, -180], [90, 180] ],
			maxBoundsViscosity: 1.0
		}).setView([20, 0], 2);
		
		// Add OpenStreetMap tiles
		L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
			attribution: '¬© OpenStreetMap contributors',
			maxZoom: 19,
			noWrap: true
		}).addTo(map);
		
		// Store player markers and real location marker
		const playerMarkers = new Map();
		let realLocationMarker = null;
		
		// Create or update style for player marker color
		function ensurePlayerStyle(playerId, color) {
			let styleEl = document.getElementById(`marker-style-${playerId}`);
			if (!styleEl) {
				styleEl = document.createElement('style');
				styleEl.id = `marker-style-${playerId}`;
				document.head.appendChild(styleEl);
			}
			styleEl.textContent = `.marker-${playerId} { border-color: ${color} !important; }`;
		}
		
		// Custom marker icon function
		function createCustomIcon(player) {
			ensurePlayerStyle(player.id, player.color);
			return L.divIcon({
				className: `custom-marker marker-${player.id}`,
				html: player.emoji,
				iconSize: [40, 40],
				iconAnchor: [20, 20],
				popupAnchor: [0, -20]
			});
		}
		
		// Update leaderboard
		function updateLeaderboard(players) {
			const leaderboard = document.getElementById('leaderboard');
			
			if (players.length === 0) {
				leaderboard.innerHTML = '<p class="text-muted">No players yet</p>';
				return;
			}
			
			// Sort players by score (highest first)
			const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
			
			leaderboard.innerHTML = sortedPlayers.map((player, index) => {
				const rank = index + 1;
				const rankClass = rank <= 3 ? `rank-${rank}` : '';
				
				// Display lastScore in green if it's greater than 0
				let scoreDisplay = player.score;
				if (player.lastScore > 0) {
					scoreDisplay += ` <span style="color: #28a745;">(+${player.lastScore})</span>`;
				}
				
				return `
					<div class="leaderboard-row" style="border-color: ${player.color};">
						<div class="leaderboard-rank ${rankClass}">${rank}</div>
						<div class="leaderboard-emoji">${player.emoji}</div>
						<div class="leaderboard-info">
							<div class="leaderboard-name">${player.name}</div>
						</div>
						<div class="leaderboard-score">${scoreDisplay}</div>
					</div>
				`;
			}).join('');
		}
		
		// Create icon for real location marker
		function createRealLocationIcon() {
			return L.divIcon({
				className: 'real-location-marker',
				html: 'üìç',
				iconSize: [60, 60],
				iconAnchor: [30, 30],
				popupAnchor: [0, -30]
			});
		}
		
		// Update markers on the map
		function updateMap(players, game) {
			// Only show player markers in WAITING state
			if (!game || game.state !== 'WAITING') {
				// Remove all player markers when not in WAITING state
				for (const [playerId, marker] of playerMarkers.entries()) {
					map.removeLayer(marker);
					playerMarkers.delete(playerId);
				}
				document.getElementById('playerCount').textContent = '0';
			} else {
				// In WAITING state, show all player guesses
				const playersWithGuesses = players.filter(p => p.currentGuess != null);
				
				// Update player count
				document.getElementById('playerCount').textContent = playersWithGuesses.length;
				
				// Create a set of current player IDs with guesses
				const currentPlayerIds = new Set(playersWithGuesses.map(p => p.id));
				
				// Remove markers for players who no longer have guesses or don't exist
				for (const [playerId, marker] of playerMarkers.entries()) {
					if (!currentPlayerIds.has(playerId)) {
						map.removeLayer(marker);
						playerMarkers.delete(playerId);
					}
				}
				
				// Add or update markers for players with guesses
				playersWithGuesses.forEach(player => {
					const lat = player.currentGuess.latitude;
					const lng = normalizeLongitude(player.currentGuess.longitude);
					
					if (playerMarkers.has(player.id)) {
						// Update existing marker position
						const marker = playerMarkers.get(player.id);
						marker.setLatLng([lat, lng]);
						marker.setIcon(createCustomIcon(player));
						marker.bindPopup(`<strong>${player.name}</strong><br>üìç ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
					} else {
						// Create new marker
						const marker = L.marker([lat, lng], {
							icon: createCustomIcon(player)
						}).addTo(map);
						
						marker.bindPopup(`<strong>${player.name}</strong><br>üìç ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
						playerMarkers.set(player.id, marker);
					}
				});
			}
			
			// Handle real location marker in WAITING state
			if (game && game.state === 'WAITING' && game.currentLocation) {
				const lat = game.currentLocation.latitude;
				const lng = game.currentLocation.longitude;
				
				if (realLocationMarker) {
					map.removeLayer(realLocationMarker);
				}
				
				realLocationMarker = L.marker([lat, lng], {
					icon: createRealLocationIcon(),
					zIndexOffset: 1000
				}).addTo(map);
				
				realLocationMarker.bindPopup(`<strong>Real Location</strong><br>üìç ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
			} else {
				// Remove real location marker if not in WAITING state or no location
				if (realLocationMarker) {
					map.removeLayer(realLocationMarker);
					realLocationMarker = null;
				}
			}
		}
		
		// Store current game state
		let currentGameState = null;
		
		// Fetch players and update map
		async function fetchAndUpdatePlayers() {
			try {
				const [playersResponse, gameResponse] = await Promise.all([
					fetch('/api/players'),
					fetch('/api/game')
				]);
				
				if (playersResponse.ok && gameResponse.ok) {
					const players = await playersResponse.json();
					const game = await gameResponse.json();
					currentGameState = game;
					
					updateMap(players, game);
					updateLeaderboard(players);
					
					// Update status
					const statusEl = document.getElementById('updateStatus');
					statusEl.classList.remove('updating');
					statusEl.innerHTML = '<span class="pulse"></span><span>Live updates active</span>';
				} else {
					console.error('Failed to fetch players or game');
				}
			} catch (error) {
				console.error('Error fetching players:', error);
				const statusEl = document.getElementById('updateStatus');
				statusEl.classList.add('updating');
				statusEl.innerHTML = '<span class="pulse"></span><span>Update error</span>';
			}
		}
		
		// Initial load
		fetchAndUpdatePlayers();
		
		// Setup WebSocket connection for real-time updates
		const socket = new SockJS('/ws');
		const stompClient = Stomp.over(socket);
		
		stompClient.connect({}, function(frame) {
			console.log('Connected to WebSocket');
			
			// Subscribe to game updates
			stompClient.subscribe('/topic/game', function(message) {
				const game = JSON.parse(message.body);
				// Update players and game state when game changes
				fetchAndUpdatePlayers();
				displayCurrentLocation(game.currentLocation, game);
			});
		}, function(error) {
			console.error('WebSocket connection error:', error);
			// Fallback to polling if WebSocket fails
			setInterval(fetchAndUpdatePlayers, 2000);
		});
		
		// Load and display current location and game state
		async function loadCurrentLocation() {
			try {
				const response = await fetch('/api/game');
				if (response.ok) {
					const game = await response.json();
					displayCurrentLocation(game.currentLocation, game);
				}
			} catch (error) {
				console.error('Error loading current location:', error);
			}
		}
		
		function displayCurrentLocation(location, game) {
			const container = document.getElementById('currentLocationDisplay');
			if (!container) return;
			
			// Build game state badge
			let stateEmoji = '‚è∏Ô∏è';
			let stateDisplay = game ? game.state : 'WAITING';
			let stateClass = stateDisplay.toLowerCase().replace('_', '-');
			
			if (game) {
				if (game.state === 'WAITING') {
					stateEmoji = '‚è∏Ô∏è';
				} else if (game.state === 'COUNTING_DOWN') {
					stateEmoji = '‚è≥';
					stateDisplay = `COUNTDOWN (${game.countdownSecondsLeft}s)`;
				} else if (game.state === 'PLAYING') {
					stateEmoji = '‚ñ∂Ô∏è';
					stateDisplay = `PLAYING (${game.roundSecondsLeft}s)`;
				}
			}
			
			container.innerHTML = `
				<div class="location-header">
					<div class="location-label">Current Location</div>
					<div class="status-badge-small status-${stateClass}">
						${stateEmoji} ${stateDisplay}
					</div>
				</div>
			`;
			
			if (location && location.url) {
				container.innerHTML += `
					<img src="${location.url}" 
						alt="Current Location" 
						class="location-display-image"
						onerror="this.style.display='none';">
				`;
				
				// Show description only in WAITING state
				if (game && game.state === 'WAITING' && location.description) {
					container.innerHTML += `
						<div class="location-description-display">
							${location.description}
						</div>
					`;
				}
			} else {
				container.innerHTML += `<div class="location-display-empty">No current location</div>`;
			}
			
			container.style.display = 'block';
		}
		
		// Load current location on page load and refresh every 5 seconds
		loadCurrentLocation();
		setInterval(loadCurrentLocation, 5000);
	</script>
	
	<!-- Current Location Display -->
	<div id="currentLocationDisplay" class="current-location-display"></div>
</body>
</html>

